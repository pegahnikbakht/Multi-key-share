(* 

Key establishment protocol

Message 1: server -> device : {ID,Auth,R,Se}
Message 2: device -> server : {Ack,Device ID}

*)

const IDa:bitstring.    (*ID of DeviceA*)
const IDb:bitstring.    (*ID of DeviceB*)


type nonce.  
type server.
type device.
type key.
type point.


const G:point.               (*Generator point of the Elliptic Curve*)


fun mult(bitstring, point) : point.
equation forall x:bitstring, y:bitstring;
         mult(x, mult(y, G)) = mult(y, mult(x, G)).

fun xreturn(point) : bitstring.
fun yreturn(point) : bitstring.

free Qa:bitstring.              (*public key of the deviceA*)
free Qb:bitstring.              (*public key of the deviceB*)
free Q:bitstring.              (*public key of the server*)
free d:bitstring[private].              (*private key of the server*)


free r:bitstring[private].    (*random---generated by the server*)
free da:bitstring[private].    (*private Key---generated by the DeviceA*)
free ra:bitstring[private].    (*random---generated by the DeviceA*)

free db:bitstring[private].    (*private Key---generated by the DeviceB*)
free rb:bitstring[private].    (*random---generated by the DeviceB*)
free key_star:key[private].       (*authenticated_key*)


free S:server.
free Da, Db:device.

(* Message authentication code (MAC) *)
fun mac(key,nonce,bitstring,point,bitstring) : bitstring.


(* Shared key encryption *)
fun sencrypt(bitstring,key): bitstring.
reduc forall x: bitstring, y: key; sdecrypt(sencrypt(x,y),y) = x.


(* Shared key encryption for key *)
fun sencryptkey(key,key): key.
reduc forall x: key, y: key; sdecryptkey(sencryptkey(x,y),y) = x.

fun hash(bitstring):bitstring.
fun ack_hash(nonce,bitstring):bitstring.
fun append(bitstring,bitstring):bitstring.
fun xor(bitstring,bitstring):bitstring.
fun mul(bitstring,bitstring):bitstring.
fun add(bitstring,point):point.
fun concat(bitstring,point,bitstring):bitstring.
fun set_fun(bitstring,bitstring):bitstring.
fun deset(bitstring,bitstring):bitstring.



(* Secrecy assumptions *)
not attacker (new key_star).

(* Queries *)

free c : channel.
(* Query reachability and secrecy *)
query attacker ( da ).
query attacker ( ra ).
query attacker ( db ).
query attacker ( rb ).

(* Queries for correspondence *)
event initDevice(bitstring,bitstring).
event initserver(bitstring,nonce,bitstring,point,bitstring).
event termDevice(bitstring,nonce,bitstring,point,bitstring).
event termserver(bitstring,bitstring).


query a:bitstring,b:nonce,c:bitstring,d:point,e:bitstring; event(termDevice(a,b,c,d,e))==>event(initserver(a,b,c,d,e)).
query a:bitstring,b:bitstring; event(termserver(a,b))==>event(initDevice(a,b)).


(* Process Server *)
let serverS(key_star: key) =
let R = mult(r,G) in
new S1:bitstring;
new S2:bitstring;
let S1 = add(mul(d,Qa),R)  in
let x1 = xreturn(S1) in
let y1 = yreturn(S1) in
let S2 = add(mul(d,Qb),R)  in
let x2 = xreturn(S2) in
let y2 = yreturn(S2) in
new sessionid:nonce;
new x_prim_1:bitstring;
new x_prim_2:bitstring;
let x_prim_1 = xor(x2,y1) in
let x_prime_2 = xor(x1,y2) in
let Se = set_fun( x_prim_1, x_prim_2) in
let shared_key = hash(xor(x1,x2)) in 
let Auth = hash (concat(shared_key,R, Se)) in
let HMAC = mac (key_star, sessionid,Auth,R,Se ) in 
event initserver(HMAC,sessionid,Auth,R,Se);
event initserver(HMAC,sessionid,Auth,R,Se);  
out(c,(HMAC,sessionid,Auth,R,Se));
in (c,(ack1:bitstring,IDa_new:bitstring));
in (c,(ack2:bitstring,IDb_new:bitstring));
event termDevice(HMAC,sessionid,Auth,R,Se);
event termDevice(HMAC,sessionid,Auth,R,Se).


(* Process DeviceA *)
let deviceA(key_star: key) =  
in(c,(HMAC:bitstring,sessionid:nonce,Auth:bitstring,R:point,Se:bitstring));
let HMAC_prime = mac(key_star,sessionid,Auth,R,Se) in
if HMAC = HMAC_prime then
let S1 = add(mul(da,Q),R) in
let x1 = xreturn(S1) in
let y1 = yreturn(S1) in
new index:bitstring;
let x_prime_1 = deset(Se,index) in
let x_prime_2 = deset(Se,index) in
let shared_key = hash(xor(xor(x1,y1),x_prime_1)) in
if Auth = hash (concat(shared_key,R, Se)) then
let ack1 = ack_hash(sessionid,Qa) in
event initDevice(IDa,ack1);
out(c,(ack1,IDa));
event termserver(IDa,ack1).


(* Process DeviceB *)
let deviceB(key_star: key) =  
in(c,(HMAC:bitstring,sessionid:nonce,Auth:bitstring,R:point,Se:bitstring));
let HMAC_prime = mac(key_star,sessionid,Auth,R,Se) in
if HMAC = HMAC_prime then
let S2 = add(mul(db,Q),R) in
let x2 = xreturn(S2) in
let y2 = yreturn(S2) in
new index:bitstring;
let x_prime_1 = deset(Se,index) in
let x_prime_2 = deset(Se,index) in
let shared_key = hash(xor(xor(x2,y2),x_prime_2)) in
if Auth = hash (concat(shared_key,R,Se)) then
let ack2 = ack_hash(sessionid,Qa) in
event initDevice(IDb,ack2);
out(c,(ack2,IDb));
event termserver(IDb,ack2).




(* Start process *)
process 
     (* establishing key *)
      new key_star : key;

      (* Launch an unbounded number of sessions *)
      (  ( ! deviceA (key_star))|( ! serverS (key_star )) |( ! deviceB (key_star)) )








